# 3rd party gems
require 'http/cookie_jar/hash_store'
require 'http/cookie_jar'
require 'http/cookie'

module Msf
  class Exploit
    class Remote
      module HTTP
        # Acts as a wrapper for the 3rd party CookieJar (http-cookie)
        class HttpCookieJar
          def initialize
            @cookie_jar = ::HTTP::CookieJar.new({
              store: HashStoreWithoutAutomaticExpiration
            })
          end

          def add(cookie)
            raise TypeError, "Passed cookie is of class '#{cookie.class}' and not a subclass of '#{Msf::Exploit::Remote::HTTP::HttpCookie}" unless cookie.is_a?(Msf::Exploit::Remote::HTTP::HttpCookie)

            @cookie_jar.add(cookie)
            self
          end

          def delete(cookie)
            return if @cookie_jar.cookies.empty?
            raise TypeError, "Passed cookie is of class '#{cookie.class}' and not a subclass of '#{Msf::Exploit::Remote::HTTP::HttpCookie}" unless cookie.is_a?(Msf::Exploit::Remote::HTTP::HttpCookie)

            @cookie_jar.delete(cookie)
            self
          end

          # Iterates over all cookies that are not expired in no particular
          # order.
          def cookies
            @cookie_jar.cookies
          end

          def clear
            @cookie_jar.clear
          end

          # Removes expired cookies and returns self.  If `session` is true,
          # all session cookies are removed as well.
          def cleanup(expire_all = false)
            @cookie_jar.cleanup(expire_all)
          end

          def empty?
            @cookie_jar.empty?
          end

          def parse(set_cookie_header, origin_url, options = nil)
            ::HTTP::Cookie.parse(set_cookie_header, origin_url, options)
          end

          def parse_and_merge(set_cookie_header, origin_url, options = nil)
            parsed_cookies = ::HTTP::Cookie.parse(set_cookie_header, origin_url, options)
            parsed_cookies.each { |c| add(Msf::Exploit::Remote::HTTP::HttpCookie.new(c)) }
            parsed_cookies
          end
        end

        class HashStoreWithoutAutomaticExpiration < ::HTTP::CookieJar::HashStore
          # On top of iterating over every item in the store, +::HTTP::CookieJar::HashStore+ also deletes any expired cookies
          # and has the option to filter cookies based on whether they are parent of a passed url.
          #
          # We've removed the extraneous features in the overwritten method.
          #   - The deletion of cookies while you're iterating over them complicated simple cookie management. It also
          #     prevented sending expired cookies if needed for an exploit
          #   - Any URL passed for filtering could be resolved to nil if it was improperly formed or resolved to a eTLD,
          #     which was too brittle for our uses
          def each(uri = nil)
            raise ArgumentError, "HashStoreWithoutAutomaticExpiration.each doesn't support url filtering" if uri

            synchronize do
              @jar.each do |_domain, paths|
                paths.each do |_path, hash|
                  hash.each do |_name, cookie|
                    yield cookie
                  end
                end
              end
            end
            self
          end
        end
      end
    end
  end
end
