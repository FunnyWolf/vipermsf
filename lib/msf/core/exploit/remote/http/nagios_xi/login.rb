# -*- coding: binary -*-

module Msf::Exploit::Remote::HTTP::NagiosXi::Login
  include Msf::Exploit::Remote::HTTP::NagiosXi::URIs
  # performs a Nagios XI login
  #
  # @param user [String] Username
  # @param pass [String] Password
  # @param finish_install [Boolean] Boolean indicating if the module should finish installing Nagios XI on target hosts if the installation hasn't been completed or the license agreement is not signed
  # @return [Array] Array containing a response code and an Array containing one of four possibilities: the HTTP response body and session cookies if the Nagios XI backend was accessed successfully; nil if Nagios XI hasn't been fully installed; cookies and the nsp token if the license agreement is not signed; otherwise an error message
  def nagios_xi_login(user, pass, finish_install)
    print_status('Attempting to authenticate to Nagios XI...')

    # Visit the login page in order to obtain the cookies and the `nsp_str` token required for authentication
    res_pre_login = send_request_cgi({
      'method' => 'GET',
      'uri' => nagios_xi_login_url,
    })

    unless res_pre_login
      return [1, ['Connection failed']]
    end

    unless res_pre_login.code == 200 && res_pre_login.body.include?('>Nagios XI<')
      # Check if we are perhaps dealing with a Nagios XI app that hasn't been fully installed yet
      unless res_pre_login.code == 302 && res_pre_login.body.include?('>Nagios XI<') && res_pre_login.headers['Location'].end_with?('/install.php')
        return [3, ['Target is not a Nagios XI application']]
      end

      print_warning('The target seems to be a Nagios XI application that has not been fully installed yet.')
      unless finish_install
        return [2, ['You can let the module complete the installation by setting `FINISH_INSTALL` to true.']]
      end

      return [4, [nil]]
    end

    # Grab the necessary tokens required for authentication
    nsp = get_nsp(res_pre_login)
    if nsp.nil?
      return [2, ['Unable to obtain the value of the `nsp_str` token required for authentication']]
    end

    pre_auth_cookies = res_pre_login.get_cookies
    if pre_auth_cookies.blank?
      return [2, ['Unable to obtain the cookies required for authentication']]
    end

    # authenticate
    res_login = send_request_cgi({
      'method' => 'POST',
      'uri' => nagios_xi_login_url,
      'cookie' => pre_auth_cookies,
      'vars_post' => {
        'nsp' => nsp,
        'pageopt' => 'login',
        'username' => user,
        'password' => pass
      }
    })

    unless res_login
      return [1, ['Connection failed']]
    end

    unless res_login.code == 302 && res_login.headers['Location'] == 'index.php'
      return [2, ['Received unexpected reply while trying to authenticate. Please check your credentials.']]
    end

    # Grab the cookies
    auth_cookies = res_login.get_cookies

    if auth_cookies.blank?
      return [2, ['Unable to obtain the cookies required for authentication']]
    end

    # Make sure we only use the cookies we need, otherwise we may encounter a session timeout
    auth_cookies = clean_cookies(pre_auth_cookies, auth_cookies)

    # Try to visit the dasboard
    visit_nagios_dashboard(auth_cookies, finish_install)
  end

  # Compares cookies obtained before and after authentication and modifies the
  # latter to remove cookies that may cause session timeouts
  #
  # @param pre_auth_cookies [String] Cookies obtained before authenticating to Nagios XI
  # @param auth_cookies [String] Cookies obtained while authenticating to Nagios XI
  # @return [String, nil] String containing the cookies required for authentication, stripped off unnecessary/unwanted cookies, nil if one or both of the parameters passed to this method are nil
  def clean_cookies(pre_auth_cookies, auth_cookies)
    if pre_auth_cookies.nil? || auth_cookies.nil?
      return nil
    end
    # Nagios XI may sometimes send the cookie `nagiosxi=deleted;` as part of the cookies after authentication.
    # This was observed when trying to access Nagios XI 5.3.0 when the license agreement had not been accepted yet.
    # The `nagiosxi=deleted;` cookie should be filtered out, since it may break authentication.
    if auth_cookies.include?('nagiosxi=deleted;')
      auth_cookies = auth_cookies.gsub('nagiosxi=deleted;', '').strip
    end

    # Remove duplicate cookies, necessary to make the next check work in case multiple
    # identical cookies were set (as observed on older Nagios versions)
    auth_cookies_array = auth_cookies.split(' ')
    auth_cookies_array.uniq!
    auth_cookies = auth_cookies_array.join(' ')

    # For newer Nagios XI versions, we need to remove the pre_auth cookies from the auth_cookies
    # string, otherwise the session will timeout. However, older Nagios XI versions use a single cookie
    # which has the same name both before and after authentication.
    unless pre_auth_cookies == auth_cookies
      if auth_cookies.include?(pre_auth_cookies)
        auth_cookies = auth_cookies.gsub(pre_auth_cookies, '').strip
      end
    end

    auth_cookies
  end

  # Performs an HTTP GET request to the Nagios XI backend to verify if authentication succeeded
  #
  # @param auth_cookies [String] Cookies required for authentication
  # @param finish_install [Boolean] Boolean indicating if the module should finish installing Nagios XI on target hosts if the installation hasn't been completed or the license agreement is not signed
  # @return [Array] Array containing a result code and an Array containing one of three possibilities: an HTTP response body and cookies if the Nagios XI backend was accessed successfully; cookies and the nsp token if the license agreement is not signed; otherwise an error message
  def visit_nagios_dashboard(auth_cookies, finish_install)
    # Visit the index page to verify we successfully authenticated
    res_index = send_request_cgi({
      'method' => 'GET',
      'uri' => nagios_xi_backend_url,
      'cookie' => auth_cookies
    })

    unless res_index
      return [1, ['Connection failed']]
    end

    unless res_index.code == 200 && res_index.body.include?('>Home Dashboard<')
      # Check if we need to sign the license agreement
      unless res_index.code == 302 && res_index.headers['Location'].end_with?('login.php?showlicense')
        return [2, ['Received unexpected reply while trying to acess the NagiosXI home dashboard after authenticating.']]
      end

      print_warning('The Nagios XI license agreement has not yet been signed on the target.')
      unless finish_install
        return [2, ['You can let the module sign the Nagios XI license agreement by setting `FINISH_INSTALL` to true.']]
      end

      nsp = get_nsp(res_index)
      if nsp.nil?
        return [2, ['Failed to obtain the nsp token required for signing the license agreement.']]
      end

      return [5, [auth_cookies, nsp]]
    end

    # Return the HTTP resonse body and the authentication cookies.
    # The response body can be used to obtain the version number.
    # The cookies can be used by exploit modules to send authenticated requests.
    [0, [res_index.body, auth_cookies]]

  end

  # Grabs the nsp_str value from an HTTP response using regex
  #
  # @param res [Rex::Proto::Http::Response] HTTP response
  # @return [String, nil] nsp_str value, nil if not found
  def get_nsp(res)
    nsp = res.body.scan(/nsp_str = "([a-z0-9]+)/)&.flatten&.first
  end

  # Performs an authentication attempt. If the server does not return a response,
  # a second attempt is made after a delay of 5 seconds
  #
  # @param username [String] Username required for authentication
  # @param password [String] Password required for authentication
  # @param finish_install [Boolean] Boolean indicating if the module should finish installing Nagios XI on target hosts if the installation hasn't been completed or the license agreement is not signed
  # @return [Array] Array containing the HTTP response body and session cookies if the Nagios XI backend was accessed successfully, otherwise Array containing an error code and an error message
  def login_after_install_or_license(username, password, finish_install)
    # After installing Nagios XI or signing the license agreement, we sometimes don't receive a server response.
    # This loop ensures that at least 2 login attempts are performed if this happens, as the second one usually works.
    second_attempt = false
    while true
      login_result, error_message = nagios_xi_login(username, password, finish_install)

      break unless error_message == ['Connection failed']

      if second_attempt
        print_warning('The server is still not responding. If you wait a few seconds and rerun the module, it might still work.')
        break
      else
        print_warning('No response received from the server. This can happen after installing Nagios XI or signing the license agreement')
        print_status('The module will wait for 5 seconds and retry.')
        second_attempt = true
        sleep 5
      end
    end

    return [login_result, error_message]

  end
end
