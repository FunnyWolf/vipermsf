require 'spec_helper'

RSpec.describe Msf::Exploit::Remote::HTTP::HttpCookieJar do
  def random_string(min_len = 1, max_len = 12)
    str = Faker::Alphanumeric.alpha(number: max_len)
    str[0, rand(min_len..max_len)]
  end

  def random_cookie
    Msf::Exploit::Remote::HTTP::HttpCookie.new(
      random_string,
      random_string,
      max_age: Faker::Number.within(range: 1..100),
      path: '/' + random_string,
      secure: Faker::Boolean.boolean,
      httponly: Faker::Boolean.boolean,
      domain: random_string
    )
  end

  let(:cookie_jar) { described_class.new }

  before(:each) do
    Timecop.freeze(Time.local(2008, 9, 5, 10, 5, 30))
  end

  after(:each) do
    Timecop.return
  end

  describe 'empty?' do
    it 'will return true when no cookies are in a cookie_jar' do
      # cookie_jar made in before

      e = cookie_jar.empty?

      expect(e).to eq(true)
    end

    it 'will return false when a cookie has been added to a cookie_jar' do
      c = random_cookie

      cookie_jar.add(c)
      e = cookie_jar.empty?

      expect(e).to eq(false)
    end
  end

  describe 'clear' do
    it 'will make no changes to an empty cookiejar' do
      # empty cookie_jar made in before

      cookie_jar.clear

      expect(cookie_jar.empty?).to eq(true)
    end

    it 'will return true when populated cookie_jar has been cleared' do
      c = random_cookie

      cookie_jar.add(c)
      cookie_jar.clear

      expect(cookie_jar.empty?).to eq(true)
    end
  end

  describe 'cookies' do
    it 'will return an empty array when no cookies have been added to the jar' do
      # cookie_jar made in before

      c_array = cookie_jar.cookies

      expect(c_array.class).to eq(Array)
      expect(c_array.empty?).to eq(true)
    end

    it 'will return an array of all cookies added to the cookie_jar when called with no url param' do
      c_array = []
      Faker::Number.within(range: 1..10).times do
        c = random_cookie

        c_array.append(c)
        cookie_jar.add(c)
      end

      jar_array = cookie_jar.cookies

      expect(c_array.sort).to eq(jar_array.sort)
    end
  end

  describe 'add' do
    it 'unacceptable cookie without a domain will throw an ArgumentError' do
      c = Msf::Exploit::Remote::HTTP::HttpCookie.new(
        random_string,
        random_string,
        path: '/' + random_string
      )

      expect do
        cookie_jar.add(c)
      end.to raise_error(ArgumentError)
    end

    it 'unacceptable cookie without a path will throw an ArgumentError' do
      c = Msf::Exploit::Remote::HTTP::HttpCookie.new(
        random_string,
        random_string,
        domain: random_string
      )

      expect do
        cookie_jar.add(c)
      end.to raise_error(ArgumentError)
    end

    it 'acceptable cookie added to cookie_jar successfully' do
      c = random_cookie

      cookie_jar.add(c)

      expect(cookie_jar.cookies[0] == c)
    end

    it 'acceptable cookie added to cookie_jar containing cookie with the same name, domain, and path will result in an overwrite' do
      c = random_cookie
      c_dup = random_cookie
      c_dup.name = c.name
      c_dup.domain = c.domain
      c_dup.path = c.path

      cookie_jar.add(c)
      cookie_jar.add(c_dup)

      expect(cookie_jar.cookies).to match_array([c_dup])
    end

    it 'variable not a subclass of ::HttpCookie will raise TypeError' do
      int = 1

      expect do
        cookie_jar.add(int)
      end.to raise_error(TypeError)
    end
  end

  describe 'delete' do
    it 'used on an empty jar will return nil' do
      # cookie_jar made in before

      n = cookie_jar.delete(random_cookie)

      expect(n).to eq(nil)
    end

    it 'passed cookie with same name, domain, and path as cookie in jar, will delete cookie in jar' do
      c = random_cookie
      c_dup = random_cookie
      c_dup.name = c.name
      c_dup.domain = c.domain
      c_dup.path = c.path

      cookie_jar.add(c)
      cookie_jar.delete(c_dup)

      expect(cookie_jar.empty?).to eq(true)
    end

    it 'passed a cookie different name, domain, and path as cookie in jar, will not delete cookie in jar' do
      c = random_cookie
      c_dup = random_cookie
      c_dup.name = c.name + random_string(1, 1)
      c_dup.domain = c.domain + random_string(1, 1)
      c_dup.path = c.path + random_string(1, 1)

      cookie_jar.add(c)
      cookie_jar.delete(c_dup)

      expect(cookie_jar.cookies.length).to eq(1)
      expect(cookie_jar.cookies[0]).to eql(c)
    end

    it 'variable not a subclass of ::HttpCookie will not raise TypeError when the cookie_jar is empty' do
      int = Faker::Number.within(range: 1..100)

      n = cookie_jar.delete(int)

      expect(n).to eq(nil)
      expect(cookie_jar.empty?).to eq(true)
    end

    it 'variable not a subclass of ::HttpCookie will raise TypeError when the cookie_jar is not empty' do
      cookie_jar.add(random_cookie)
      int = Faker::Number.within(range: 1..100)

      expect do
        cookie_jar.delete(int)
      end.to raise_error(TypeError)
    end
  end

  describe 'cleanup' do
    it 'will make no changes to an empty cookiejar' do
      # empty cookie_jar made in before

      cookie_jar.cleanup

      expect(cookie_jar.empty?).to eq(true)
    end

    it 'will remove expired cookies with max_age value' do
      expired_cookies = [random_cookie, random_cookie]
      expired_cookies[0].max_age = 1
      expired_cookies[1].max_age = 1
      expired_cookies[0].created_at = Time.local(2008, 9, 5, 10, 5, 1)
      expired_cookies[1].created_at = Time.local(2008, 9, 5, 10, 5, 1)
      cookies = [random_cookie, random_cookie]
      cookies[0].max_age = 10000
      cookies[1].max_age = 10000
      cookies[0].created_at = Time.now
      cookies[1].created_at = Time.now

      cookies.each { |c| cookie_jar.add(c) }
      expired_cookies.each { |c| cookie_jar.add(c) }
      cookie_jar.cleanup

      expect(cookie_jar.cookies).to match_array(cookies)
    end

    it 'will remove expired cookies with expires value' do
      expired_cookies = [random_cookie, random_cookie]
      expired_cookies[0].expires = Time.local(2008, 9, 3, 10, 5, 0)
      expired_cookies[1].expires = Time.local(2008, 9, 4, 10, 5, 0)
      cookies = [random_cookie, random_cookie]
      cookies[0].expires = Time.local(2008, 9, 6, 10, 5, 0)
      cookies[1].expires = Time.local(2008, 9, 7, 10, 5, 0)

      cookies.each { |c| cookie_jar.add(c) }
      expired_cookies.each { |c| cookie_jar.add(c) }
      cookie_jar.cleanup

      expect(cookie_jar.cookies).to match_array(cookies)
    end
  end

  describe '#dup' do
    it 'ensures the cookie jar is additionally duped' do
      original = cookie_jar
      dup = cookie_jar.dup

      5.times { original.add(random_cookie) }
      2.times { dup.add(random_cookie) }

      expect(original.cookies.length).to be 5
      expect(dup.cookies.length).to be 2
    end
  end
end
